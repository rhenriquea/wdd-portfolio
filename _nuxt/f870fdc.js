(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{374:function(e,t,n){"use strict";n.r(t);n(32);var o=n(6),c={asyncData:function(e){return Object(o.a)(regeneratorRuntime.mark((function t(){var n,o;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.$content,t.next=3,n("week7").sortBy("slug").fetch();case 3:return o=t.sent,t.abrupt("return",{examples:o});case 5:case"end":return t.stop()}}),t)})))()}},r=n(17),component=Object(r.a)(c,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[n("h1",[e._v("Higher-order Functions in Javascript")]),e._v(" "),n("small",[e._v("\n    The notes this week is based on a short explanation on closures, callbacks, and how to access\n    an unspecified number of arguments in a higher-order function with the spread operator\n  ")]),e._v(" "),n("h2",{staticClass:"mb"},[e._v("First class functions")]),e._v(" "),e._m(0),e._v(" "),n("h2",[e._v("Closures")]),e._v(" "),n("p",[e._v("\n    A closure is how functions in Javascript can remember and access its surrounding state (or\n    lexical environment). Closures are created whenever a function accesses a variable defined\n    outside of its own scope. See the example below of a closure:\n  ")]),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[0]}}),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),n("h2",{staticClass:"mb"},[e._v("Higher-order Functions")]),e._v(" "),e._m(3),e._v(" "),n("span",{staticClass:"important"},[e._v("\n    When a callback function is invoked within your enclosing function and needs access to an\n    outer variable, closures are created.\n  ")]),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[1]}}),e._v(" "),e._m(4),e._v(" "),n("h2",{staticClass:"mb"},[e._v("Implementing an Advanced Higher-order Function")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),n("strong",[e._v("Starter Code:")]),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[2]}}),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),n("h3",[e._v("Accessing Unknown Number of Arguments")]),e._v(" "),e._m(10),e._v(" "),n("p",[e._v("In pseudocode:")]),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[3]}}),e._v(" "),e._m(11),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[4]}}),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),n("blockquote",[e._v("\n    “Spread syntax allows an iterable such as an array expression or string to be expanded in\n    places where zero or more arguments (for function calls) or elements (for array literals) are\n    expected…”\n  ")]),e._v(" "),e._m(14),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[5]}}),e._v(" "),n("h3",[e._v("Refactoring with Callbacks")]),e._v(" "),e._m(15),e._v(" "),n("nuxt-content",{attrs:{document:e.examples[6]}}),e._v(" "),e._m(16),e._v(" "),n("h3",[e._v("Sources")]),e._v(" "),e._m(17)],1)}),[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    A\n    "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function"}},[this._v("first-class function")]),this._v("\n    is a function that is treated like any other variable. This concept allows functions in\n    Javascript to be accepted as an argument to another function, returned by another enclosing\n    function, or even assigned as the value of a variable. In Javascript, functions are treated as\n    objects. This is necessary in order to create higher-order functions.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    In the global scope of the snippet, there is a global variable,\n    "),n("code",{staticClass:"hl"},[e._v("globalVar")]),e._v(", that is declared and instantiated with a value of\n    "),n("code",{staticClass:"hl"},[e._v("“xyz”")]),e._v(". "),n("code",{staticClass:"hl"},[e._v("outerFunc")]),e._v(" is an IIFE — an\n    "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"}},[e._v("immediately invoked function expression")]),e._v("\n    — that accepts the parameter of "),n("code",{staticClass:"hl"},[e._v("outerArg")]),e._v(" on line 2 and is invoked with\n    the argument of "),n("code",{staticClass:"hl"},[e._v("123")]),e._v(" on line 12. Within\n    "),n("code",{staticClass:"hl"},[e._v("outerFunc")]),e._v(", a variable is declared, "),n("code",{staticClass:"hl"},[e._v("outerVar")]),e._v(",\n    and instantiated with the value of "),n("code",{staticClass:"hl"},[e._v("‘a’")]),e._v(".\n    "),n("code",{staticClass:"hl"},[e._v("outerFunc")]),e._v(" also includes "),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v("."),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v("\n    is also an IIFE that accepts the parameter of\n    "),n("code",{staticClass:"hl"},[e._v("innerArg")]),e._v(" on line 4 and is invoked with the argument\n    "),n("code",{staticClass:"hl"},[e._v("456")]),e._v(" on line 11. Within "),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v(", it declares\n    and instantiates a variable, "),n("code",{staticClass:"hl"},[e._v("innerVar")]),e._v(", with the value of\n    "),n("code",{staticClass:"hl"},[e._v("‘b’")]),e._v(". Inside "),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v(", it logs each of the\n    variable values.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v(" acts as a closure here. As you can see from the logs\n    (delineated by "),n("code",{staticClass:"hl"},[e._v("//")]),e._v(" above), "),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v(" can access\n    the value of every variable in this snippet. "),n("code",{staticClass:"hl"},[e._v("innerFunc")]),e._v(" creates its own\n    scope and can access "),n("code",{staticClass:"hl"},[e._v("innerVar")]),e._v(" within this scope, but can\n    "),n("strong",{staticClass:"ir ko"},[n("em",[e._v("also ")])]),e._v("access variables in its enclosing scope,\n    "),n("code",{staticClass:"hl"},[e._v("outerFunc")]),e._v(", as well as any globally declared variables ("),n("code",{staticClass:"hl"},[e._v("globalVar")]),e._v("). Basically, inner closures can always look outward, but the reverse is "),n("em",[e._v("not")]),e._v(" true.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    Simply put, a\n    "),t("a",{attrs:{href:"https://eloquentjavascript.net/05_higher_order.html"}},[this._v("higher-order function")]),this._v("\n    is just a first-class function that can accept another function as an argument\n    "),t("strong",[t("em",[this._v("and/or")])]),this._v(" returns a function. A common example of a higher-order\n    function is when a function accepts a second function (either named or anonymous) as an\n    argument. The function passed in as an argument is also known as a\n    "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function"}},[this._v("callback function")]),this._v(".\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    In the above snippet, lines 1–3 declare the function\n    "),n("code",{staticClass:"hl"},[e._v("hello")]),e._v(". In the function declaration for\n    "),n("code",{staticClass:"hl"},[e._v("start")]),e._v(" on line 4, we pass in "),n("code",{staticClass:"hl"},[e._v("callback")]),e._v(" as a\n    parameter. On line 7, "),n("code",{staticClass:"hl"},[e._v("start")]),e._v(" is invoked and the function\n    "),n("code",{staticClass:"hl"},[e._v("hello")]),e._v(" is passed in as the argument. "),n("code",{staticClass:"hl"},[e._v("start")]),e._v(" logs\n    "),n("code",{staticClass:"hl"},[e._v("“hello world”")]),e._v(" when invoked because "),n("code",{staticClass:"hl"},[e._v("hello")]),e._v(" acts\n    as a callback, which will itself be invoked within "),n("code",{staticClass:"hl"},[e._v("start")]),e._v(" (see line 2).\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    The below snippet will create a higher-order function, "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(", that\n    will accept a callback function. The function should log the "),n("em",[e._v("callback")]),e._v(" function’s\n    arguments ("),n("strong",[n("em",[e._v("not")])]),n("em"),e._v(" "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v("’s arguments); evaluate the return value of the\n    callback function; and finally, log the return value of the callback function.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    There are three functions that will serve as exemplary callback functions for\n    "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(": "),n("code",{staticClass:"hl"},[e._v("add")]),e._v(", "),n("code",{staticClass:"hl"},[e._v("square")]),e._v(",\n    and "),n("code",{staticClass:"hl"},[e._v("sumArray")]),e._v(". These functions each evaluate a mathematical equation\n    based on the parameters supplied. To invoke the higher-order function,\n    "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(", a variable declaration is made (see lines 12-14 below) and the\n    value is a function expression (i.e. "),n("code",{staticClass:"hl"},[e._v("logger(add)")]),e._v("). By using our\n    higher-order function, the function expression can accept a callback function.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("code",{staticClass:"hl"},[e._v("logger")]),e._v(" fulfills the requirements of a higher-order function: it\n    accepts a function as a callback and will "),n("strong",[e._v("also")]),e._v(" return a function that will\n    evaluate the callback function. Also remember, "),n("code",{staticClass:"hl"},[e._v("logAdd")]),e._v(",\n    "),n("code",{staticClass:"hl"},[e._v("logSquare")]),e._v(", and "),n("code",{staticClass:"hl"},[e._v("logSum")]),e._v(" will each create their\n    own closure when invoked; they share the same reference to the\n    "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(" function but will create different lexical environments.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    When approaching this problem, first consider what’s happening in the variable declarations on\n    lines 12–14. On line 16\n    "),n("code",{staticClass:"hl"},[e._v("logAdd(1, 2)")]),e._v(" will invoke "),n("code",{staticClass:"hl"},[e._v("add")]),e._v(" with the\n    arguments of "),n("code",{staticClass:"hl"},[e._v("1")]),e._v(" and "),n("code",{staticClass:"hl"},[e._v("2")]),e._v(" within\n    "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(":"),n("code",{staticClass:"hl"},[e._v("logger(add(1, 2))")]),e._v(". By contextualizing\n    the expected functionality, we see that the main obstacle is that the\n    "),n("code",{staticClass:"hl"},[e._v("add")]),e._v(" function within "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(" needs to have\n    access to the arguments that will be passed in to "),n("code",{staticClass:"hl"},[e._v("logAdd")]),e._v(". However,\n    "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(" also needs to be abstract enough to accept any number of\n    arguments so that it can also successfully evaluate any callback. While\n    "),n("code",{staticClass:"hl"},[e._v("logAdd")]),e._v(" requires two arguments, "),n("code",{staticClass:"hl"},[e._v("logSum")]),e._v(" requires\n    an array.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("span",{staticClass:"important"},[this._v("\n    Inner functions can always look "),t("em",[this._v(" outwards")]),this._v(" to their enclosing scope.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    The "),t("code",{staticClass:"hl"},[this._v("combined")]),this._v(" function below can handle accepting an unknown number of\n    arguments. (Later we can abstract the inner functionality into a callback.)\n    "),t("code",{staticClass:"hl"},[this._v("combined")]),this._v("’s arguments will be passed to an inner function that expects\n    a specific number of arguments. It requires two arguments that are numbers.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    First is included the functionality of "),t("code",{staticClass:"hl"},[this._v("add")]),this._v(" as the return value of\n    "),t("code",{staticClass:"hl"},[this._v("combined")]),this._v(".\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    In order to give the anonymous arrow function (lines 2-4) access to\n    "),t("code",{staticClass:"hl"},[this._v("combined")]),this._v("’s parameters, we utilize an IIFE. The argument that is passed\n    in on line 4 would match that of line 1 in the above snippet.\n  ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("span",{staticClass:"important mb"},[this._v("\n    We can use the spread operator to give us access to an unknown number of arguments.\n    "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"}},[this._v("MDN docs")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("\n    By implementing the spread operator in both our outer function’s parameters\n    "),t("em",[this._v("and")]),this._v(" when we immediately invoke the anonymous function expression, the inner function\n    can access these variables without the outer function specifying how many to expect.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    First, we no longer need to include the functionality of\n    "),n("code",{staticClass:"hl"},[e._v("add")]),e._v(" as we did in "),n("code",{staticClass:"hl"},[e._v("combined")]),e._v(" above. The\n    "),n("code",{staticClass:"hl"},[e._v("callback")]),e._v(" that we pass into "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v(" will handle\n    that. Second, we can expand the parameters of an enclosing, outer function so that an inner\n    function can access zero or more arguments with the spread operator.\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n    In the above code snippet, lines 2 and 9 in\n    "),n("code",{staticClass:"hl"},[e._v("logger1")]),e._v(" spread the arguments that "),n("code",{staticClass:"hl"},[e._v("combined")]),e._v(" was\n    previously passing to its inner function explicitly. Here, we have to remember that\n    "),n("code",{staticClass:"hl"},[e._v("logAdd")]),e._v(" will create a closure for\n    "),n("code",{staticClass:"hl"},[e._v("logger(add)")]),e._v("when invoked and "),n("code",{staticClass:"hl"},[e._v("logAdd")]),e._v(" will pass\n    in the arguments for "),n("code",{staticClass:"hl"},[e._v("logger")]),e._v("’s "),n("code",{staticClass:"hl"},[e._v("callback")]),e._v(".The\n    anonymous function (lines 2–6) gives "),n("code",{staticClass:"hl"},[e._v("callback")]),e._v(" access to\n    "),n("code",{staticClass:"hl"},[e._v("…args")]),e._v(" by passing them in as the argument (line 2).\n  ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[n("p",[e._v("\n        MDN Web Docs:\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS"}},[e._v("Object-oriented Javascript for beginners")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function"}},[e._v("First-class Function")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"}},[e._v("Closures")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function"}},[e._v("Callback function")]),e._v(", "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"}},[e._v("IIFE")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"}},[e._v("Spread syntax")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments"}},[e._v("arguments object")]),e._v(",\n        "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"}},[e._v("Function.prototype.apply()")])])]),e._v(" "),n("li",[n("p",[e._v("\n        Javascript in Plain English:\n        "),n("a",{attrs:{href:"https://medium.com/javascript-in-plain-english/what-are-javascript-programming-paradigms-3ef0f576dfdb"}},[e._v("What are Javascript Programming Paradigms?")])])]),e._v(" "),n("li",[n("p",[e._v("\n        Code Burst:\n        "),n("a",{attrs:{href:"https://codeburst.io/imperative-vs-declarative-javascript-8b5e45a602dd"}},[e._v("Imperative vs Declarative Javascript")])])]),e._v(" "),n("li",[n("p",[e._v("\n        Launch School:\n        "),n("a",{attrs:{href:"https://medium.com/launch-school/javascript-weekly-an-introduction-to-first-class-functions-9d069e6fb137"}},[e._v("An Introduction to First-Class Functions")])])]),e._v(" "),n("li",[n("p",[e._v("\n        Eloquent Javascript:\n        "),n("a",{attrs:{href:"https://eloquentjavascript.net/05_higher_order.html"}},[e._v("Higher-Order Functions")])])]),e._v(" "),n("li",[n("p",[e._v("\n        Bits and Pieces:\n        "),n("a",{attrs:{href:"https://blog.bitsrc.io/understanding-higher-order-functions-in-javascript-75461803bad"}},[e._v("Understanding Higher-Order Functions in Javascript")])])])])}],!1,null,null,null);t.default=component.exports}}]);